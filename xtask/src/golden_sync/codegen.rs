//! Code generation for golden test modules
//!
//! Generates mod.rs stubs and updates the main golden_tests/mod.rs.

use std::collections::{BTreeMap, BTreeSet};
use std::fs;
use std::path::Path;

use anyhow::Result;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use regex::Regex;

use super::snapshot_parser::TestInfo;

/// Format a TokenStream into pretty-printed Rust code
fn format_tokens(tokens: TokenStream) -> String {
    let file = syn::parse2(tokens).expect("generated code should be valid syntax");
    prettyplease::unparse(&file)
}

/// Parse ops string into a TokenStream (raw code insertion)
fn parse_ops(ops: &str) -> TokenStream {
    ops.parse().unwrap_or_else(|_| quote! { /* parse error */ })
}

/// Generate a mod.rs for a golden test module with extracted ops
pub fn generate_mod_stub(module_name: &str, tests: &BTreeMap<String, TestInfo>) -> String {
    let module_comment = format!(" Golden tests for {}", module_name);

    // Generate ops functions
    let ops_fns: Vec<TokenStream> = tests
        .iter()
        .map(|(fn_name, test_info)| {
            let ops_fn_name = format_ident!("{}_ops", fn_name);
            let body = if let Some(ops) = &test_info.ops {
                let ops_tokens = parse_ops(ops);
                quote! { vec![#ops_tokens] }
            } else {
                quote! {
                    // No ops extracted - define manually
                    vec![]
                }
            };
            quote! {
                fn #ops_fn_name() -> Vec<Op> {
                    #body
                }
            }
        })
        .collect();

    // Generate LTR tests
    let ltr_tests: Vec<TokenStream> = tests
        .keys()
        .map(|fn_name| {
            let test_fn_name = format_ident!("{}", fn_name);
            let ops_fn_name = format_ident!("{}_ops", fn_name);
            let golden_name = fn_name.as_str();
            quote! {
                #[test]
                fn #test_fn_name() {
                    let mut layout = set_up_empty();
                    check_ops_on_layout(&mut layout, #ops_fn_name());
                    assert_golden!(layout.snapshot(), #golden_name);
                }
            }
        })
        .collect();

    // Generate RTL tests
    let rtl_tests: Vec<TokenStream> = tests
        .keys()
        .map(|fn_name| {
            let test_fn_name = format_ident!("{}_rtl", fn_name);
            let ops_fn_name = format_ident!("{}_ops", fn_name);
            let golden_name = fn_name.as_str();
            quote! {
                #[test]
                fn #test_fn_name() {
                    let mut layout = set_up_empty_rtl();
                    check_ops_on_layout(&mut layout, #ops_fn_name());
                    assert_golden_rtl!(layout, #golden_name);
                }
            }
        })
        .collect();

    let tokens = quote! {
        #![doc = #module_comment]
        //!
        //! AUTO-GENERATED by `cargo xtask sync-golden`

        use super::*;

        // ============================================================================
        // Test Operations (extracted from snapshot tests)
        // ============================================================================

        #(#ops_fns)*

        // ============================================================================
        // LTR Tests
        // ============================================================================

        #(#ltr_tests)*

        // ============================================================================
        // RTL Tests
        // ============================================================================

        #(#rtl_tests)*
    };

    format_tokens(tokens)
}

/// Update golden_tests/mod.rs to include new modules
pub fn update_golden_mod_rs(golden_dir: &Path, new_modules: &[String], dry_run: bool) -> Result<()> {
    let mod_file = golden_dir.join("mod.rs");
    let content = fs::read_to_string(&mod_file)?;
    
    // Find existing module declarations
    let existing_re = Regex::new(r#"#\[path = "(\d+_[^/]+)/mod\.rs"\]"#).unwrap();
    let existing: BTreeSet<String> = existing_re
        .captures_iter(&content)
        .map(|c| c[1].to_string())
        .collect();
    
    // Find modules to add
    let to_add: Vec<&String> = new_modules
        .iter()
        .filter(|m| !existing.contains(*m))
        .collect();
    
    if to_add.is_empty() {
        println!("   No new modules to add");
        return Ok(());
    }
    
    // Generate new module declarations
    let mut additions = String::new();
    for module in &to_add {
        // Convert module name to a valid Rust identifier
        let mod_ident = module.replace('-', "_");
        // Remove leading digits for the module name
        let mod_ident = mod_ident.trim_start_matches(|c: char| c.is_ascii_digit() || c == '_');
        
        additions.push_str(&format!("\n#[path = \"{}/mod.rs\"]\n", module));
        additions.push_str(&format!("mod {};\n", mod_ident));
    }
    
    // Append to the file
    if dry_run {
        println!("   Would add to mod.rs:");
        for module in &to_add {
            println!("     - {}", module);
        }
    } else {
        let mut new_content = content;
        new_content.push_str(&additions);
        fs::write(&mod_file, new_content)?;
        println!("   âœ… Added {} new module(s)", to_add.len());
    }
    
    Ok(())
}
